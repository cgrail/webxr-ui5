{"version":3,"sources":["webpack:///XLSXExportUtils.js","webpack:///webpack/bootstrap e33b7c81308be115ca77","webpack:///./client/src/export-utils.js","webpack:///./client/src/provider/ODataDataProvider.js","webpack:///./client/src/provider/RequestHandler.js","webpack:///./client/src/filesaver/FileSaver.js"],"names":["XLSXExportUtils","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","35","ODataDataProvider","FileSaver","oData","fetch","requestData","getConverter","saveFile","36","getValue","oRow","oCol","keys","reduce","obj","key","convertData","aRows","aCols","forEach","col","row","getColsToConvert","mSettings","workbook","columns","result","properties","Array","aKeys","split","length","push","type","getDataConverter","aColumns","processDataUrl","sDataUrl","iSkip","iTop","mDataUrl","reSkip","reTop","URI","parse","query","test","serialize","build","fnProcessCallback","getUrl","sNextUrl","mNextUrl","dataUrl","replace","fnOnError","sMessage","error","fnOnDataReceived","oResult","aData","iFetchedRows","fPercent","iRemainingRows","mCallbackParams","bCancelled","results","isArray","iAvailableRows","iTotalRows","finished","progress","Math","round","__next","mRequest","min","iBatchSize","RequestHandler","sendRequest","then","catch","rows","fnConvertData","mDataSource","dataSource","count","MAX_ROWS","sizeLimit","batchSize","serviceUrl","url","mUri","path","slice","hash","fragment","method","useBatch","headers","cancel","37","oRequest","Error","sendBatchRequest","sendGetRequest","Promise","fnResolve","fnReject","sHeaderKey","xhr","XMLHttpRequest","onload","this","status","responseText","JSON","e","HTTP_WRONG_RESPONSE_MSG","onerror","HTTP_ERROR_MSG","onabort","open","setRequestHeader","toLowerCase","send","createGuid","r","random","toString","sKey","sValue","boundary","body","aLines","iEnd","iLength","iStart","oResponseData","join","38","blob","link","downloadSupported","fnSave","Blob","document","createElementNS","data","fileName","download","href","URL","createObjectURL","dispatchEvent","MouseEvent","reader","FileReader","onloadend","opened","window","location","readAsDataURL","navigator","msSaveOrOpenBlob"],"mappings":"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","file":"XLSXExportUtils.js","sourcesContent":["var XLSXExportUtils =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 35);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 35:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Bundle all utilities into a single module\nvar ODataDataProvider = __webpack_require__(36);\nvar FileSaver = __webpack_require__(38);\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n/***/ }),\n\n/***/ 36:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar RequestHandler = __webpack_require__(37);\n\nvar MAX_ROWS = 1000000; // 1,000,000\n\n/**\n * OData interface for requesting chunked data.\n */\n\n/**\n * Gets converted property value from raw data.\n * Navigation properties are parsed.\n *\n * @param {Object} oRow - Raw data row\n * @param {Object} oCol - Column information\n * @param {Array} oCol.keys - Property name or key path for navigation properties\n * @returns {number|string|boolean} - The converted property value\n * @private\n */\nfunction getValue(oRow, oCol) {\n\n\t// Get property value\n\tvar value = oCol.keys.reduce(function(obj, key) {\n\t\treturn obj && obj[key];\n\t}, oRow);\n\n\treturn value;\n}\n\n/**\n * Function to process the JSON result array from a ODataService.\n *\n * @param {Array} aRows - Data array that contains the received data\n * @param {Array} aCols - Columns that need to be converted\n * @returns {Array} - An array of rows\n *\n * @private\n */\nfunction convertData(aRows, aCols) {\n\taCols.forEach(function(col) {\n\t\taRows.forEach(function(row) {\n\t\t\trow[col.property] = getValue(row, col);\n\t\t});\n\t});\n\n\treturn aRows;\n}\n\n/**\n * The function returns array of columns that need special conversion for values.\n *\n * @param {Object} mSettings - Configuration object\n * @returns {Array} - Collection of columns that need special conversion for their values\n * @private\n */\nfunction getColsToConvert(mSettings) {\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\n\t\tvar properties;\n\n\t\t// Handle aggregated properties and single properties\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\n\n\t\tproperties.forEach(function(property) {\n\n\t\t\t// Convert navigation property and date fields\n\t\t\tvar aKeys = property.split('/');\n\n\t\t\tif (aKeys.length > 1) {\n\t\t\t\tresult.push({\n\t\t\t\t\tproperty: property,\n\t\t\t\t\tkeys: aKeys,\n\t\t\t\t\ttype: col.type\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}, []);\n}\n\n/**\n * The function returns a conversion function for raw data.\n *\n * @param {Object} mSettings Configuration object\n * @returns {function} Conversion function\n */\nfunction getDataConverter(mSettings) {\n\tvar aColumns = getColsToConvert(mSettings);\n\n\treturn function(aRows) {\n\t\treturn convertData(aRows, aColumns);\n\t};\n}\n\n/**\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\n *\n * @param {string} sDataUrl\n * @param {number} iSkip - The amount of items that are already present and will be skipped\n * @param {number} iTop - The amount of items that should be requested with this query\n * @returns {string} processed data URL\n */\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\n\tvar mDataUrl, reSkip = /\\$skip\\=[0-9]+/, reTop = /\\$top\\=[0-9]+/;\n\n\tif (!sDataUrl) {\n\t\treturn '';\n\t}\n\n\tmDataUrl = URI.parse(sDataUrl);\n\n\tmDataUrl.query = mDataUrl.query || '';\n\t// Add missing $skip if needed\n\tif (!reSkip.test(mDataUrl.query)) {\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\n\t}\n\t// Add missing $top if needed\t\n\tif (!reTop.test(mDataUrl.query)) {\n\t\tmDataUrl.query += '&$top=' + iTop;\n\t}\n\n\treturn (URI.serialize || URI.build)(mDataUrl);\n}\n\n/**\n * The function requests several chunks of data until the maximum\n * amount of data is fetched.\n *\n * @param {Object} mSettings - Configuration object\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\n * @returns {Object} - Object reference that allows to cancel the current processing\n */\nfunction requestData(mSettings, fnProcessCallback) {\n\tvar iAvailableRows = 0;\n\tvar mDataSource = mSettings.dataSource;\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\n\tvar bCancelled = false;\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\n\tvar fnConvertData = getDataConverter(mSettings);\n\tvar mRequest;\n\n\t/**\n\t * Nested function to remove not used information from the URL\n\t *\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\n\t * @returns {string} - A clean URL\n\t */\n\tfunction cleanUrl(url) {\n\t\tvar mUri;\n\n\t\tif (!url) {\n\t\t\treturn '';\n\t\t}\n\n\t\tmUri = URI.parse(url);\n\n\t\tmUri.path = mUri.path || '';\n\t\tif (mUri.path.slice(-1) !== '/') {\n\t\t\tmUri.path = mUri.path + '/';\n\t\t}\n\t\tdelete mUri.query;\n\t\tdelete mUri.hash;\n\t\tdelete mUri.fragment;\n\n\t\treturn (URI.serialize || URI.build)(mUri);\n\t}\n\n\n\t/**\n\t * Creates the download URL for the next query.\n\t *\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\n\t * @param {number} iTop - The amount of items that should be requested with this query\n\t * @param {string} sNextUrl - A reference to the next bulk of data that was returned by the previous request\n\t * @returns {string} - The URL for the next query\n\t */\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\n\t\tvar mDataUrl, mNextUrl;\n\n\t\tmDataUrl = URI.parse(dataUrl);\n\n\t\tif (sNextUrl) { // Use __next from server, replace origin if proxy was used\n\t\t\tmNextUrl = URI.parse(sNextUrl);\n\t\t\tmDataUrl.query = mNextUrl.query;\n\t\t} else { // Use $skip and $top\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\n\t\t\t\t.replace(/\\$skip\\=[0-9]+/g, '$skip=' + iSkip)\n\t\t\t\t.replace(/\\$top\\=[0-9]+/g, '$top=' + iTop);\n\t\t}\n\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\n\t}\n\n\t/**\n\t * Inner function that processes request handler exceptions.\n\t *\n\t * @param {string} sMessage - Error message.\n\t */\n\tfunction fnOnError(sMessage) {\n\t\tfnProcessCallback({\n\t\t\terror: sMessage\n\t\t});\n\t}\n\n\t/**\n\t * Inner function that processes the received data. Processing\n\t * the data before executing the callback function allows to\n\t * apply transformations to the data.\n\t *\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\n\t */\n\tfunction fnOnDataReceived(oResult) {\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\n\t\tvar mCallbackParams = {};\n\n\t\tif (bCancelled) {\n\t\t\treturn; // Cancelled by the application\n\t\t}\n\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\n\t\taData = (Array.isArray(aData)) ? aData : [];\n\t\tiFetchedRows = aData.length;\n\n\t\tiAvailableRows += iFetchedRows;\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\n\t\tfPercent = iAvailableRows / iTotalRows;\n\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\n\n\t\t// Check if next url is provided\n\t\tsNextUrl = (oResult && oResult.d && oResult.d.__next) || null;\n\n\t\tif (!mCallbackParams.finished) {\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\n\t\t\tRequestHandler\n\t\t\t\t.sendRequest(mRequest)\n\t\t\t\t.then(fnOnDataReceived)\n\t\t\t\t.catch(fnOnError);\n\t\t}\n\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\n\t\tfnProcessCallback(mCallbackParams); // Return result\n\t}\n\n\t// Execution\n\tmRequest = {\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\n\t\tdataUrl: getUrl(0, iBatchSize),\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\n\t\theaders: mDataSource.headers\n\t};\n\n\tRequestHandler\n\t\t.sendRequest(mRequest)\n\t\t.then(fnOnDataReceived)\n\t\t.catch(fnOnError);\n\n\treturn { cancel: function() { bCancelled = true; } };\n}\n\nmodule.exports = {\n\trequestData: requestData,\n\tgetConverter: getDataConverter\n};\n\n/***/ }),\n\n/***/ 37:\n/***/ (function(module, exports) {\n\n/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\n/**\n * Creates and sends a GET request to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar sHeaderKey;\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.onload = function() {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open('GET', oRequest.dataUrl, true);\n\t\txhr.setRequestHeader('accept', 'application/json');\n\n\t\t/* Set custom header information on the request as well as on the batch request */\n\t\tfor (sHeaderKey in oRequest.headers) {\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\n\t\t\t}\n\t\t}\n\n\t\txhr.send();\n\t});\n}\n\n/**\n * Creates a pseudo random GUID. This algorithm is not suitable for\n * cryptographic purposes and should not be used therefore.\n *\n * @returns {string} - Generated GUID\n */\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\n\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Creates a $batch request and sends it to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = 'batch_' + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\t\tvar sKey, sValue;\n\n\t\txhr.onload = function() {\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\n\n\t\t\tresponseText = this.responseText;\n\t\t\taLines = this.responseText.split('\\r\\n');\n\n\t\t\t// TBD: check return codes\n\t\t\tiStart = 0;\n\t\t\tiLength = aLines.length;\n\t\t\tiEnd = iLength - 1;\n\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\n\t\t\t\tiStart++;\n\t\t\t}\n\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join('\\r\\n');\n\n\t\t\ttry {\n\t\t\t\toResponseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(oResponseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\n\t\t// Create request\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\n\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\n\n\t\tbody.push('--' + boundary);\n\t\tbody.push('Content-Type: application/http');\n\t\tbody.push('Content-Transfer-Encoding: binary');\n\t\tbody.push('');\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\n\n\t\t/* Set header information on the request as well as on the batch request */\n\t\tfor (sKey in oRequest.headers) {\n\t\t\tsValue = oRequest.headers[sKey];\n\n\t\t\tif (sKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\n\t\t\t}\n\t\t\tbody.push(sKey + ':' + sValue);\n\t\t}\n\n\t\tbody.push('');\n\t\tbody.push('');\n\t\tbody.push('--' + boundary + '--');\n\t\tbody.push('');\n\t\tbody = body.join('\\r\\n');\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n/***/ }),\n\n/***/ 38:\n/***/ (function(module, exports) {\n\n/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function(data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t};\n\t}\n\n\t/* In case of iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function(data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function() {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t};\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function(data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// XLSXExportUtils.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e33b7c81308be115ca77","// Bundle all utilities into a single module\nvar ODataDataProvider = require('./provider/ODataDataProvider.js');\nvar FileSaver = require('./filesaver/FileSaver.js');\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/export-utils.js\n// module id = 35\n// module chunks = 1","var RequestHandler = require('./RequestHandler.js');\n\nvar MAX_ROWS = 1000000; // 1,000,000\n\n/**\n * OData interface for requesting chunked data.\n */\n\n/**\n * Gets converted property value from raw data.\n * Navigation properties are parsed.\n *\n * @param {Object} oRow - Raw data row\n * @param {Object} oCol - Column information\n * @param {Array} oCol.keys - Property name or key path for navigation properties\n * @returns {number|string|boolean} - The converted property value\n * @private\n */\nfunction getValue(oRow, oCol) {\n\n\t// Get property value\n\tvar value = oCol.keys.reduce(function(obj, key) {\n\t\treturn obj && obj[key];\n\t}, oRow);\n\n\treturn value;\n}\n\n/**\n * Function to process the JSON result array from a ODataService.\n *\n * @param {Array} aRows - Data array that contains the received data\n * @param {Array} aCols - Columns that need to be converted\n * @returns {Array} - An array of rows\n *\n * @private\n */\nfunction convertData(aRows, aCols) {\n\taCols.forEach(function(col) {\n\t\taRows.forEach(function(row) {\n\t\t\trow[col.property] = getValue(row, col);\n\t\t});\n\t});\n\n\treturn aRows;\n}\n\n/**\n * The function returns array of columns that need special conversion for values.\n *\n * @param {Object} mSettings - Configuration object\n * @returns {Array} - Collection of columns that need special conversion for their values\n * @private\n */\nfunction getColsToConvert(mSettings) {\n\treturn mSettings.workbook.columns.reduce(function(result, col) {\n\t\tvar properties;\n\n\t\t// Handle aggregated properties and single properties\n\t\tproperties = col.property instanceof Array ? col.property : [col.property];\n\n\t\tproperties.forEach(function(property) {\n\n\t\t\t// Convert navigation property and date fields\n\t\t\tvar aKeys = property.split('/');\n\n\t\t\tif (aKeys.length > 1) {\n\t\t\t\tresult.push({\n\t\t\t\t\tproperty: property,\n\t\t\t\t\tkeys: aKeys,\n\t\t\t\t\ttype: col.type\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}, []);\n}\n\n/**\n * The function returns a conversion function for raw data.\n *\n * @param {Object} mSettings Configuration object\n * @returns {function} Conversion function\n */\nfunction getDataConverter(mSettings) {\n\tvar aColumns = getColsToConvert(mSettings);\n\n\treturn function(aRows) {\n\t\treturn convertData(aRows, aColumns);\n\t};\n}\n\n/**\n * The function processes the dataURL and adds any missing $skip or $top before initial use.\n *\n * @param {string} sDataUrl\n * @param {number} iSkip - The amount of items that are already present and will be skipped\n * @param {number} iTop - The amount of items that should be requested with this query\n * @returns {string} processed data URL\n */\nfunction processDataUrl(sDataUrl, iSkip, iTop) {\n\tvar mDataUrl, reSkip = /\\$skip\\=[0-9]+/, reTop = /\\$top\\=[0-9]+/;\n\n\tif (!sDataUrl) {\n\t\treturn '';\n\t}\n\n\tmDataUrl = URI.parse(sDataUrl);\n\n\tmDataUrl.query = mDataUrl.query || '';\n\t// Add missing $skip if needed\n\tif (!reSkip.test(mDataUrl.query)) {\n\t\tmDataUrl.query += (mDataUrl.query.length ? '&' : '') + '$skip=' + iSkip;\n\t}\n\t// Add missing $top if needed\t\n\tif (!reTop.test(mDataUrl.query)) {\n\t\tmDataUrl.query += '&$top=' + iTop;\n\t}\n\n\treturn (URI.serialize || URI.build)(mDataUrl);\n}\n\n/**\n * The function requests several chunks of data until the maximum\n * amount of data is fetched.\n *\n * @param {Object} mSettings - Configuration object\n * @param {function} fnProcessCallback - Callback function that is triggered when data is received\n * @returns {Object} - Object reference that allows to cancel the current processing\n */\nfunction requestData(mSettings, fnProcessCallback) {\n\tvar iAvailableRows = 0;\n\tvar mDataSource = mSettings.dataSource;\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\n\tvar bCancelled = false;\n\tvar dataUrl = processDataUrl(mDataSource.dataUrl, 0, iBatchSize);\n\tvar fnConvertData = getDataConverter(mSettings);\n\tvar mRequest;\n\n\t/**\n\t * Nested function to remove not used information from the URL\n\t *\n\t * @param {string} url - A URL that may contain a path, hash and request parameters\n\t * @returns {string} - A clean URL\n\t */\n\tfunction cleanUrl(url) {\n\t\tvar mUri;\n\n\t\tif (!url) {\n\t\t\treturn '';\n\t\t}\n\n\t\tmUri = URI.parse(url);\n\n\t\tmUri.path = mUri.path || '';\n\t\tif (mUri.path.slice(-1) !== '/') {\n\t\t\tmUri.path = mUri.path + '/';\n\t\t}\n\t\tdelete mUri.query;\n\t\tdelete mUri.hash;\n\t\tdelete mUri.fragment;\n\n\t\treturn (URI.serialize || URI.build)(mUri);\n\t}\n\n\n\t/**\n\t * Creates the download URL for the next query.\n\t *\n\t * @param {number} iSkip - The amount of items that are already present and will be skipped\n\t * @param {number} iTop - The amount of items that should be requested with this query\n\t * @param {string} sNextUrl - A reference to the next bulk of data that was returned by the previous request\n\t * @returns {string} - The URL for the next query\n\t */\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\n\t\tvar mDataUrl, mNextUrl;\n\n\t\tmDataUrl = URI.parse(dataUrl);\n\n\t\tif (sNextUrl) { // Use __next from server, replace origin if proxy was used\n\t\t\tmNextUrl = URI.parse(sNextUrl);\n\t\t\tmDataUrl.query = mNextUrl.query;\n\t\t} else { // Use $skip and $top\n\t\t\tmDataUrl.query = (mDataUrl.query || '')\n\t\t\t\t.replace(/\\$skip\\=[0-9]+/g, '$skip=' + iSkip)\n\t\t\t\t.replace(/\\$top\\=[0-9]+/g, '$top=' + iTop);\n\t\t}\n\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\n\t}\n\n\t/**\n\t * Inner function that processes request handler exceptions.\n\t *\n\t * @param {string} sMessage - Error message.\n\t */\n\tfunction fnOnError(sMessage) {\n\t\tfnProcessCallback({\n\t\t\terror: sMessage\n\t\t});\n\t}\n\n\t/**\n\t * Inner function that processes the received data. Processing\n\t * the data before executing the callback function allows to\n\t * apply transformations to the data.\n\t *\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\n\t */\n\tfunction fnOnDataReceived(oResult) {\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\n\t\tvar mCallbackParams = {};\n\n\t\tif (bCancelled) {\n\t\t\treturn; // Cancelled by the application\n\t\t}\n\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\n\t\taData = (Array.isArray(aData)) ? aData : [];\n\t\tiFetchedRows = aData.length;\n\n\t\tiAvailableRows += iFetchedRows;\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\n\t\tfPercent = iAvailableRows / iTotalRows;\n\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\n\n\t\t// Check if next url is provided\n\t\tsNextUrl = (oResult && oResult.d && oResult.d.__next) || null;\n\n\t\tif (!mCallbackParams.finished) {\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\n\t\t\tRequestHandler\n\t\t\t\t.sendRequest(mRequest)\n\t\t\t\t.then(fnOnDataReceived)\n\t\t\t\t.catch(fnOnError);\n\t\t}\n\n\t\tmCallbackParams.rows = fnConvertData(aData); // Normalize data\n\t\tfnProcessCallback(mCallbackParams); // Return result\n\t}\n\n\t// Execution\n\tmRequest = {\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\n\t\tdataUrl: getUrl(0, iBatchSize),\n\t\tmethod: mDataSource.useBatch ? 'BATCH' : 'GET',\n\t\theaders: mDataSource.headers\n\t};\n\n\tRequestHandler\n\t\t.sendRequest(mRequest)\n\t\t.then(fnOnDataReceived)\n\t\t.catch(fnOnError);\n\n\treturn { cancel: function() { bCancelled = true; } };\n}\n\nmodule.exports = {\n\trequestData: requestData,\n\tgetConverter: getDataConverter\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/ODataDataProvider.js\n// module id = 36\n// module chunks = 1","/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === 'BATCH' && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\n/**\n * Creates and sends a GET request to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar sHeaderKey;\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.onload = function() {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open('GET', oRequest.dataUrl, true);\n\t\txhr.setRequestHeader('accept', 'application/json');\n\n\t\t/* Set custom header information on the request as well as on the batch request */\n\t\tfor (sHeaderKey in oRequest.headers) {\n\t\t\tif (sHeaderKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sHeaderKey, oRequest.headers[sHeaderKey]);\n\t\t\t}\n\t\t}\n\n\t\txhr.send();\n\t});\n}\n\n/**\n * Creates a pseudo random GUID. This algorithm is not suitable for\n * cryptographic purposes and should not be used therefore.\n *\n * @returns {string} - Generated GUID\n */\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tvar r = Math.random() * 16 | 0, // Bitwise OR is equivalent to Math.floor() but faster\n\t\t\tv = c === 'x' ? r : ((r & 0x3) | 0x8); // In case of c != 'x', the value is always between 0x8 and 0xB\n\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Creates a $batch request and sends it to the backend service.\n *\n * @param {Object} oRequest - Request object that contains all necessary information to create the batch request\n * @returns {Promise} - A Promise that resolves in a JSON object containing the fetched data\n */\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function(fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = 'batch_' + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\t\tvar sKey, sValue;\n\n\t\txhr.onload = function() {\n\t\t\tvar responseText, aLines, iEnd, iLength, iStart, oResponseData;\n\n\t\t\tresponseText = this.responseText;\n\t\t\taLines = this.responseText.split('\\r\\n');\n\n\t\t\t// TBD: check return codes\n\t\t\tiStart = 0;\n\t\t\tiLength = aLines.length;\n\t\t\tiEnd = iLength - 1;\n\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0, 1) !== '{') {\n\t\t\t\tiStart++;\n\t\t\t}\n\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== '}') {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join('\\r\\n');\n\n\t\t\ttry {\n\t\t\t\toResponseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(oResponseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function() {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\n\t\t// Create request\n\t\txhr.open('POST', oRequest.serviceUrl + '$batch', true);\n\n\t\txhr.setRequestHeader('Accept', 'multipart/mixed');\n\t\txhr.setRequestHeader('Content-Type', 'multipart/mixed;boundary=' + boundary);\n\n\t\tbody.push('--' + boundary);\n\t\tbody.push('Content-Type: application/http');\n\t\tbody.push('Content-Transfer-Encoding: binary');\n\t\tbody.push('');\n\t\tbody.push('GET ' + getUrl + ' HTTP/1.1');\n\n\t\t/* Set header information on the request as well as on the batch request */\n\t\tfor (sKey in oRequest.headers) {\n\t\t\tsValue = oRequest.headers[sKey];\n\n\t\t\tif (sKey.toLowerCase() != 'accept') {\n\t\t\t\txhr.setRequestHeader(sKey, sValue);\n\t\t\t}\n\t\t\tbody.push(sKey + ':' + sValue);\n\t\t}\n\n\t\tbody.push('');\n\t\tbody.push('');\n\t\tbody.push('--' + boundary + '--');\n\t\tbody.push('');\n\t\tbody = body.join('\\r\\n');\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/RequestHandler.js\n// module id = 37\n// module chunks = 1","/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function(data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t};\n\t}\n\n\t/* In case of iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function(data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function() {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t};\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function(data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/filesaver/FileSaver.js\n// module id = 38\n// module chunks = 1"],"sourceRoot":""}